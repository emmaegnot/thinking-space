# The Thinking Space 2024 - Handover Document

## Contents
- [Introduction](#introduction)
- [Build and Execution](#build-and-execution)
- [System Architecture](#system-architecture)
- [Project Structure](#project-structure)
- [Database Structure](#database-structure)
- [AWS Setup](#aws-setup)
- [Further Documentation](#further-documentation)

## Introduction

This document serves as a technical guide for new developers to begin working on this project, given existing code infrastructure. It will explain the purpose of a large proportion of the repository, with further code-specific details being found in comments throughout the codebase.

### What is The Thinking Space?

The Thinking Space aims to tackle behavioural problems in children by providing them with a way to communicate and express themselves through a selection of visual elements. In the standard teaching environment, the student-to-teacher ratio does not allow for behaviour management on a personal level, so we hope that this project will provide children with a safe environment to regulate their mood and feelings.

In order to see the client's original brief, in this folder is a pdf that shows this.

## Build and Execution

### Prerequisites

First, you will need Node.js and Docker installed on your machine:

- Install [```Node.js```](https://nodejs.org/en/download)
- Install [```Docker```](https://docs.docker.com/engine/install/)

The next step is to create a local copy of the repository:

- Run ```git clone https://github.com/spe-uob/2024-ThinkingSpace.git```

In order to install all dependencies, run ```npm install```

### Environment variables

The following variables are used for our project. Some require you to create a .env file in the root, and some are stored in GitHub secrets, so you do not need to worry about defining these.

| Variable Name   | Purpose                          | Where It's Stored           |
|-----------------|---------------------------------|-----------------------------|
| `MONGO_URI`     | Connection string for database  | GitHub Secrets, `.env` (local)|
| `AWS_ACCOUNT_ID`| The AWS account ID where the IAM role is located | GitHub Secrets   |
| `AWS_ROLE_NAME` | The name of the IAM role that GitHub Actions will assume | GitHub Secrets |
| `AWS_REGION` | The AWS region where resources will be deployed or managed | GitHub Secrets |
| `AWS_INSTANCE_ID` | The specific EC2 instance ID where the deployment is happening. Used to fetch the instanceâ€™s IP and execute commands via SSM. | GitHub Secrets |

### Accessing the website

If you just want to see the project, you can skip the setup, and access the website on the internet by navigating to [www.thethinkingspace.me](https://www.thethinkingspace.me/), and this should connect you to the website, running on an AWS EC2 instance. With every merge to the dev branch, our GitHub actions will use our Continuous Development setup to automatically deploy the changes. However, when working on a branch, it is recommended to test the site locally first, as it is best practice to only deploy a website that has been reviewed and confirmed to work.
TheOnce this is set up, you should be able to access the website.

To host and view the website locally, navigate to the root folder then in the terminal, run ```node src/server/server```. On your browser, enter the url http://localhost:3000/ and the website will appear.

### Accessing the database

The server connects to the database using MongoDB Atlas and is done by looking into the .env file for a connection string.

Your own connection string can be generated by:
1. creating a MongoDB Atlas account
2. being added to the ThinkingSpace project
3. adding your IP address to the table of known users
4. connecting to the cluster using drivers
5. Pasting this string in your .env file: MONGO_URI=mongodb+srv://admin_user:password@your-cluster.mongodb.net/myDatabase?retryWrites=true&w=majority
6. Replacing the admin_user and password with your one

### Accessing the EC2 Node
The IP address of the instance is 13.53.72.180, and this is an elastic IP so should not change.
Port 3000 is open to any IP address, and this is where the server listens to requests and hosts the website.
Port 22 is also open, but to a limited range of IP addresses. This port allows a user to SSH into the instance and run commands such as docker and git. In order to add your IP address to the range you must:
1. Log into the AWS account
2. Navigate to the EC2 Page
3. Find the security groups tab on the left
4. Edit inbound rules for the group named launch-wizard-1 - this is the one associated with the instance.
5. Add a new SSH rule, and make its source your current IP address
Following this, you will also need your own SSH key. To generate one, you must
1. Log into the AWS account
2. Navigate to the EC2 page
3. In the left menu, click Key Pairs (under "Network & Security").
4. Click Create Key Pair.
5. Enter a Key Pair Name (e.g., new-key).
6. Choose a type and format
7. Click Create Key Pair and download the file (making sure it is stored securely).
8. Go to EC2 Dashboard then Click your Instance ID.
9. Go to Click Actions then Manage Sessions then Start Session. Once inside, run:
```
cd ~/.ssh
echo "YOUR_NEW_PUBLIC_KEY" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```
Using this key, you should now be able to securely connect to the instance though SSH. You can use the command
```
ssh -i /path/to/new-key.pem ec2-user@13.53.72.180
```

## System Architecture
The architecure diagram can be found here:
![arc-diagram drawio](https://github.com/user-attachments/assets/649f387c-295e-458c-8f54-b2d369a39919)

## Project Structure
Code relating to the project itself can be found in the src folder at root level. Anything outside of this folder are files for Github, Docker, Node.js or generic project work like this README and some research. In src, the code can generally be organised into four sections: database, frontend, backend and CI.
### Database
Within the models folder, we have two pieces of Javascript code, Student.js and Teacher.js. These define the Student and Teacher data structures (referred to as schemas) that our database uses. It is similar to a class in OOP, where we define the attributes here, and create them later in the server code.
### Backend
Within the server folder, our main backend file, server.js can be found. This is the file we run to get the website up and running. It is decently long, and has carries out a range of functions.
#### Routing 
The first is to know how our server should react to a multitude of different requests. We define different blocks of logic that, when a request is made to a certain url, the server will typcially respond with ejs files, and in some cases carry out additional computation. We also specify the port it should listen on as 3000.
#### Mood matching
One example of a key function that our server carries out is our mood match algorithm. Given the data that the student has already submitted, the server will call our moodMatch function, with the parameters of a chosen shape, colour, word, additional words and a feeling force. The way this works is that first we define a list of possible words that we can match a mood to, and assign each a 2D vector, on an unpleasent-calm graph. The parameters all also have a vector associated with them. This information comes from cross-modal correspondence research. We then take the average of the vectors, scale them by the feeling force, and return the word that is closest to the new vector we have calculated.
#### Connecting to the database
Another feature the server is responsible for is connecting to the database. In our connectDB function, we have included logic, mostly for the sake of our CI (as most tests do not need to connect to the database), to run the server in a "database-free" mode when a connection string is not provided.
#### Helper functions
There are also generic helper functions. These are:
- matchMood (already mentioned)
- getSharedWords: this is legacy code for our old mood matcher algorithm
- colourToDec: legacy code. Translates a hex string to an array consisting of r, g and b int values
- generaliseColour: also legacy code. We used to let users submit any rgb value, so it would return the closest defined colour
- timeConvert: converts a timestamp to English (local) time
- connectDB (already mentioned)
- convertToValidDateFormat: converts a data string to ISO format
### Frontend
The code relating to the frontend can be found in a few different folders within src. First there is the public folder. In the server, we allow users of the website to be able to access anything in this folder. It includes images, font files and our stylesheet file, style.css, which are all needed to enhance the look of the webpages.
There is also the views folder, which contains all of our different .ejs (essentially HTML) pages. These can be fully-defined pages, or partial ones that are then loaded into the other .ejs files.
### Continuous Integration
Within the tests folder, you can find all of the CI tests that Github will automatically run for us each time we push to a branch. They essentially make requests to the server and compare the actual response with the expected response. There is a different file for each page we test.

As mentioned earlier, anything not in the src folder is general work, but I think it would be valuable to describe as many files as possible.

### Root level files

In the root level, there exist a few different files, which do a variety of things.
The first is .gitignore. This lists all of the files that we specifically do not want to track on GitHub. This includes files that are automatically generated in OS-specific and IDE-specific environments, our .env files (for security reasons) and also node modules - this last file is huge, and is only needed locally to store all of the dependencies for the project.#
Secondly, there is the Dockerfile. While the docker scripts (see [here](#docker) for an explanation of these) exist in a folder, the Dockerfile itself should be in the root. This contains docker commands for deploying the project, which is very helpful.
The next file is our license. This is simply a copy of the GNU AFFERO GENERAL PUBLIC LICENSE, which our client has chosen. It is designed to ensure that users who interact with a program over a network can access the source code of the modified version they are using.
The next two are package-lock.json and package.json. They handle all the dependencies, with the latter storing their names (this is what the command ```npm install``` looks at when installing them), and the former contains exact versions of installed dependencies, including sub-dependencies.
Finally, README.md. This is what anyone should read when first looking at our project. It is similar to this document, but goes more in depth to the user and client side of things.

### .github

The .github folder contains files that allow GitHub to automate parts of the development cycle. It contains templates and workflows.
The templates include ones for pull requests, and kanban board issues.
For our workflows, there are two files, deploy.yml and test.yml, which handle CD and CI respectively.
Deploy.yml connects to our EC2 instance using AWS SSM and sends commands to it. These commands allow us to use git and docker to get the latest version of our project, and redeploy it.
Test.yml will build the program and then run all of the tests in the test folder (see [here](#continuous-integration)). This allows us to ensure our website is functioning correctly, and as expected.


### docker

The docker file contains shell scripts for starting and stopping the docker image. There are .bat and .sh files so that it can work across OSs.

### docs

The docs folder contains informative documents and research relating to the project. Research includes UI design, analyses of ethics and a tech stack, among other things. It also contains this document, the client brief and architecture diagrams.

### node_modules

This folder is untracked by GitHub, but it will contains all of the modules that ```npm install``` creates. 

## Database Structure

In src/models, you can find our two schemas for our database - these are Student and Teacher. We have created an Entity Relationship diagram to show how these two interact:
![erd](entity-relationship-diagram)
As you can see, the teacher and student are linked by their class code, which has a many-to-one relationship. The data of any students that go through the Thinking Space process can be seen only by their teachers, but no other teachers.
We require a teacher's username to be unique, as they will use this to log in to their account. We don't bother to have accounts for students, they just need to enter their name and class code. Currently there is no way for a teacher to make an account, this must be done by manually creating one on MongoDB Atlas. We plan for this to be carried out by Raymer Enterprises, who can create accounts for teachers at schools where they choose to use this project. To access the database, see [here](#accessing-the-database).
> [!NOTE]  
> If you create an account, you should enter the password as intended. We have logic in the server that will detect if a password is unhashed, and use bcrypt to update the password.

## AWS Setup

This following is a guide that provides instructions to set up the project on AWS, including EC2, networking, domain configuration, SSL setup, and automated deployment using GitHub Actions and Docker.

### 1. Creating an EC2 Instance

1. Go to the AWS EC2 Console.
2. Click Launch Instance.
3. Choose an appropriate Amazon Machine Image (AMI), e.g., Ubuntu 22.04.
4. Select an instance type (e.g., t2.micro for free-tier usage).
5. Configure instance details
6. Configure security group:
 - Allow SSH (port 22) from your IP.
 - Allow HTTP (port 80) and HTTPS (port 443) from anywhere.
7. Launch the instance and download the SSH key pair (if creating a new one).

### 2. Assigning an Elastic IP

1. Go to the EC2 Dashboard > Elastic IPs.
2. Allocate a new Elastic IP.
3. Associate it with the created EC2 instance.

### 3. Configuring a Domain Name with Namecheap

1. Obtain a free domain from Namecheap FreeDNS. We used a GitHub education to do this
2. In the Namecheap dashboard, update DNS settings:
 - Create an A record pointing to your Elastic IP.
 - Create a CNAME record if needed.

### 4. Installing and Configuring Nginx for HTTPS

1. SSH into the EC2 instance: ```ssh -i your-key.pem ubuntu@your-elastic-ip```
2. Install Nginx: ```sudo apt update && sudo apt install -y nginx```
3. Install Certbot for SSL: ```sudo apt install -y certbot python3-certbot-nginx```
4. Obtain an SSL certificate: ```sudo certbot --nginx -d yourdomain.com -d www.yourdomain.com```
5. Verify the certificate renewal: ```sudo certbot renew --dry-run```

### 5. Setting Up IAM for GitHub Actions

1. Go to the AWS IAM Console.
2. Create a new IAM user with programmatic access.
3. Assign the following policy:
```
{
  "Effect": "Allow",
  "Action": [
    "ssm:StartSession",
    "ssm:SendCommand",
    "ssm:GetCommandInvocation"
  ],
  "Resource": "*"
}
```
4. Store the IAM credentials securely in GitHub Actions Secrets.

### 6. Deploying the Project Using GitHub Actions & Docker

#### Install Docker on the EC2 Instance

1. SSH into the instance.
2. Install Docker:
 ```sudo apt update```
 ```sudo apt install -y docker.io```
3. Add the current user to the Docker group:
 ```sudo usermod -aG docker $USER```
4. Enable and start Docker:
 ```sudo systemctl enable docker```
 ```sudo systemctl start docker```

#### Configure GitHub Actions Workflow

In our repository, navigate to .github/workflows/ and locate the deploy.yml file. This should be working, but keep note that it uses GitHub secret variables so you may have to create your own. These can be found [here](#environment-variables).

### 7. Configuring Nginx for Reverse Proxy

1. Open the Nginx configuration file:
 ```sudo nano /etc/nginx/sites-available/default```
2. Update it to proxy traffic to your Docker container:
```
server {
    listen 80;
    server_name yourdomain.com;

    location / {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```
3. Restart Nginx:
 ```sudo systemctl restart nginx```

Hopefully by dollowing these steps, you will have an EC2 instance running your project, accessible via a custom domain, secured with HTTPS, and automatically deployed via GitHub Actions.

## Further Documentation

The following table contains links to other useful documentation for tools/libraries/frameworks used within this project:

| Tool                | Documentation Link                                                           |
|---------------------|------------------------------------------------------------------------------|
| NPM                 | [https://docs.npmjs.com/](https://docs.npmjs.com/)                           |
| NodeJS              | [https://nodejs.org/docs/latest/api/](https://nodejs.org/docs/latest/api/)   |
| Express             | [https://devdocs.io/express/](https://devdocs.io/express/)                   |
| Mongoose            | [https://mongoosejs.com/docs/](https://mongoosejs.com/docs/)                 |
| Bcrypt              | [https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt) |
| Docker              | [https://docs.docker.com/](https://docs.docker.com/)                         |
| AWS                 | [https://docs.aws.amazon.com/](https://docs.aws.amazon.com/)                 |
